<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_DigitalIn" Id="{7d2e3300-1cea-46b6-825d-8d8268205915}" SpecialFunc="None">
    <Declaration><![CDATA[// Digital input FB
FUNCTION_BLOCK FB_DigitalIn extends FB_DIO IMPLEMENTS I_DigitalIn
VAR
	ibIn			AT %I*	: BOOL;							// Linked input variable
	bExternalIn				: BOOL;							// External input to trigger this digital input
	eCommand				: E_DICommand;					// Command generated by digital input
	eState					: E_DIState := E_DIState.Idle;	// State of the digital input
	bDoublePressEnabled		: BOOL := FALSE;				// Set to true to enable double press detection
	bDeferEnabled			: BOOL := TRUE;					// Set to true to enable deferring right after input
END_VAR
VAR RETAIN
	nSwitchCount			: UDINT;						// Counter for the number of times the input has switched (0-4294967295)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{e9c123cf-e5bf-40e3-ba76-dc9930be2771}" />
    <Folder Name="Properties" Id="{8938b7ae-23f7-4f42-b560-314611d281d5}" />
    <Property Name="Command" Id="{16475b16-3c70-4eb8-99a0-82460f1a7613}" FolderPath="Properties\">
      <Declaration><![CDATA[// Get the digital input command = translation from on duration of input
PROPERTY Command : E_DICommand]]></Declaration>
      <Get Name="Get" Id="{8b378237-1997-452f-8efe-cc9462d2c32e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Command := eCommand;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="EnableDefer" Id="{c3757221-2c1f-4fe9-8c16-6e9a594838e9}" FolderPath="Methods\">
      <Declaration><![CDATA[// Enable/disable deferring right after input
METHOD EnableDefer
VAR_INPUT
	bEnable		: BOOL;		// Set to true to enable deferring right after input
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDeferEnabled := bEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableDoublePress" Id="{7e416a4a-2f9f-4e34-886e-44775d7dab6e}" FolderPath="Methods\">
      <Declaration><![CDATA[// Enable/disable double press detection
METHOD EnableDoublePress
VAR_INPUT
	bEnable		: BOOL;		// Set to true to enable double press detection
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDoublePressEnabled := bEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{608868f2-1780-4a08-b37b-d21311770504}" FolderPath="Methods\">
      <Declaration><![CDATA[// Run this method every cycle
METHOD Execute
VAR_INST
	bInput					: BOOL;				// Input obtained from linked digital input or external input
	eStep					: E_DIExecuteSteps;	// State machine state
	fbTimerPressed			: TON;				// Timer to record the time the button was pressed
	fbHoldTimer				: TON;				// Timer to record the time the button was held
	tTimePressed			: TIME;				// Time button was pressed
	fbReleasedTrigger		: F_TRIG;			// Falling edge generated when button is released
	fbWaitSecondPress		: TON;				// Timer to wait for second button press after first press was detected
	fbDeferInput			: TON;				// Timer to defer new input after command
END_VAR
VAR
	sTemp					: STRING;			// Temporary string
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Only run trigger FBs in states where they are used, otherwise an edge may be missed!

// Input = linked digital input or external input
bInput := ibIn OR bExternalIn;

CASE eStep OF
	E_DIExecuteSteps.Idle:
		// Store elapsed time before running FB again
		tTimePressed := fbTimerPressed.ET;
		
		// Set state
		IF bInput THEN
			// State based on time pressed
			IF tTimePressed < T#200MS THEN
				// Pressing first time for short amount of time
				eState := E_DIState.Pressing1;
			ELSIF tTimePressed < T#2000MS THEN
				// Pressing longer but not holding
				eState := E_DIState.LongPressing;
			ELSE
				// Holding
				eState := E_DIState.Holding;
			END_IF
		END_IF
		
		// Run FBs
		fbTimerPressed(IN := bInput, PT := T#2500MS);
		fbHoldTimer(IN := bInput, PT := T#1H);
		fbReleasedTrigger(CLK := bInput);
		
		// When button is released or timer expires
		IF fbReleasedTrigger.Q OR fbTimerPressed.Q THEN			
			// Determine press type based on time pressed
			IF tTimePressed < T#500MS THEN
				// First short press detected
				eStep := E_DIExecuteSteps.FirstShortPressDetected;
			ELSIF tTimePressed < T#2000MS THEN
				// Long press detected
				eStep := E_DIExecuteSteps.LongPressDetected;
			ELSE
				// Hold detected
				// Button is still being held
				eStep := E_DIExecuteSteps.HoldDetected;
			END_IF
		END_IF
		
	E_DIExecuteSteps.FirstShortPressDetected:
		// Reset FB before using it
		fbWaitSecondPress(IN := FALSE);
		
		// Set state
		IF bInput THEN
			// Pressing second time
			eState := E_DIState.Pressing2;
		END_IF
		
		// Check if double press detection is enabled
		IF bDoublePressEnabled THEN
			eStep := E_DIExecuteSteps.WaitForSecondPress;
		ELSE
			eStep := E_DIExecuteSteps.ShortPressDetected;
		END_IF

	E_DIExecuteSteps.WaitForSecondPress:
		// Wait for second press
		
		// Set state
		IF bInput THEN
			// Pressing second time
			eState := E_DIState.Pressing2;
		END_IF
		
		// Run FBs
		fbReleasedTrigger(CLK := bInput);
		fbWaitSecondPress(IN := TRUE, PT := T#200MS);		// Wait x second for second press to occur
		
		// Check button pressed and released again
		IF fbReleasedTrigger.Q THEN
			// Double press detected
			eStep := E_DIExecuteSteps.DoublePressDetected;
		END_IF
		
		// Check if time elapsed, then it was just a single press
		IF fbWaitSecondPress.Q THEN
			// Short press detected
			eStep := E_DIExecuteSteps.ShortPressDetected;
		END_IF
		
	E_DIExecuteSteps.ShortPressDetected:
		// Log
		sTemp := 'Short press ';
		sTemp := CONCAT(sTemp, TIME_TO_STRING(tTimePressed));
		fbLogger.AddDebug(sTemp);
			
		// Set command for one cycle
		eCommand := E_DICommand.ShortPress;
		nSwitchCount := nSwitchCount + 1;
		
		eStep := E_DIExecuteSteps.Reset;
		
	E_DIExecuteSteps.DoublePressDetected:
		// Log
		sTemp := 'Double press ';
		sTemp := CONCAT(sTemp, TIME_TO_STRING(tTimePressed));
		sTemp := CONCAT(sTemp, ' - ');
		sTemp := CONCAT(sTemp, TIME_TO_STRING(fbWaitSecondPress.ET));
		fbLogger.AddDebug(sTemp);
		
		// Set command for one cycle
		eCommand := E_DICommand.DoublePress;
		nSwitchCount := nSwitchCount + 2;
		
		eStep := E_DIExecuteSteps.Reset;
	
	E_DIExecuteSteps.LongPressDetected:
		// Log
		sTemp := 'Long press ';
		sTemp := CONCAT(sTemp, TIME_TO_STRING(tTimePressed));
		fbLogger.AddDebug(sTemp);
		
		// Set command for one cycle
		eCommand := E_DICommand.LongPress;
		nSwitchCount := nSwitchCount + 1;
		
		eStep := E_DIExecuteSteps.Reset;
		
	E_DIExecuteSteps.HoldDetected:
		// Log
		sTemp := 'Hold ';
		sTemp := CONCAT(sTemp, TIME_TO_STRING(tTimePressed));
		fbLogger.AddDebug(sTemp);
		
		// Set command for one cycle
		eCommand := E_DICommand.Hold;
		nSwitchCount := nSwitchCount + 1;
		
		// Hold was detected but button release has not been detected yet
		// Detect button release before returning to idle
		eStep := E_DIExecuteSteps.WaitUntilReleased;
		
	E_DIExecuteSteps.WaitUntilReleased:
		// Reset
		eCommand := E_DICommand.None;
		
		// Store elapsed time before running FB again
		tTimePressed := fbHoldTimer.ET;
		
		// Run FB
		fbHoldTimer(IN := bInput, PT := T#1H);
		fbReleasedTrigger(CLK := bInput);
		
		// Wait until released
		IF fbReleasedTrigger.Q THEN
			// Log
			sTemp := 'Held for ';
			sTemp := CONCAT(sTemp, TIME_TO_STRING(tTimePressed));
			fbLogger.AddDebug(sTemp);
		
			eStep := E_DIExecuteSteps.Reset;
		END_IF
		
	E_DIExecuteSteps.Reset:
		// Reset
		eCommand := E_DICommand.None;
		
		IF bDeferEnabled THEN
			// Deferring enabled
			eState := E_DIState.Deferring;
		
			fbDeferInput(IN := TRUE, PT := T#500MS);
			
			IF fbDeferInput.Q THEN
				fbDeferInput(IN := FALSE);
				eState := E_DIState.Idle;
				eStep := E_DIExecuteSteps.Idle;
			END_IF
		ELSE
			// Reset immediately
			eState := E_DIState.Idle;
			eStep := E_DIExecuteSteps.Idle;
		END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Property Name="HmiData" Id="{2a06141f-bb4f-4818-a515-7ec33647a574}" FolderPath="Properties\">
      <Declaration><![CDATA[// Get HMI data
PROPERTY HmiData : ST_HmiDigitalIn]]></Declaration>
      <Get Name="Get" Id="{0d8787b9-63f9-4e01-a5c7-4c6af877d83a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[HmiData.sName := sName;
HmiData.eState := eState;
HmiData.bValue := ibIn or bExternalIn;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="SetExternalIn" Id="{10342ed0-de6c-4326-ba8e-1fac9ebf5bac}" FolderPath="Methods\">
      <Declaration><![CDATA[// Set the external input
METHOD SetExternalIn
VAR_INPUT
	bIn		: BOOL;		// External input value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bExternalIn := bIn;]]></ST>
      </Implementation>
    </Method>
    <Property Name="State" Id="{92d28c8a-5208-4731-bc57-3221c5cc583a}" FolderPath="Properties\">
      <Declaration><![CDATA[// Get the digital input state
PROPERTY State : E_DIState]]></Declaration>
      <Get Name="Get" Id="{f3237ab4-7b74-48fd-a6dd-36f2e1c10f7d}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[State := eState;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>